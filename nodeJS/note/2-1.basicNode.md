## Buffer基本操作
> Buffer对象是Node处理二进制数据的一个接口。它是Node原生提供的全局对象，可以直接使用，不需要require(‘buffer’)。

- 实例化
    + Buffer.from(array)
    + Buffer.from(string)
    + Buffer.alloc(size)
- 功能方法
    + Buffer.isEncoding() 判断是否支持该编码
    + Buffer.isBuffer() 判断是否为Buffer
    + Buffer.byteLength() 返回指定编码的字节长度，默认utf8
    + Buffer.concat() 将一组Buffer对象合并为一个Buffer对象
- 实例方法
    + write() 向buffer对象中写入内容
    + slice() 截取新的buffer对象
    + toString() 把buf对象转成字符串
    + toJson() 把buf对象转成json形式的字符串

## 核心模块API
### 路径操作
1. 路径基本操作API
	+ basename() 获取路径的最后一部分
	+ dirname() 获取路径
	+ extname() 获取扩展名称
	+ join() 拼接路径
	+ relative() 计算相对路径
	+ resolve() 解析路径
2. 路径的格式化处理
	+ format() obj->string
	```
	{
    root:'E:\\',
    dir:'E:\\node\\day02\02-code',
    base: '02.js',
    ext: '.js',
    name: '02'
	}
	```
	+ parse() string->obj
	```
	'd:\qqq\www\abc.txt'
	```
3. 路径的属性
	+ delimiter 路径分隔符（win:'\' linux:'/'）
	+ sep 环境变量分隔符(win:';' linux:':')

## 异步操作
### 基本概念
- 异步I/O input/output:
    1. 文件操作
    2. 网络操作
- 在浏览器中也存在异步操作：
    1. 定时任务
    2. 事件处理
    3. Ajax回调处理
- Node.js中异步执行的任务：
    1. 文件I/O
    2. 网络I/O

js的运行是单线程的,故引入事件队列机制。

Node.js中的事件模型与浏览器中的事件模型类似：单线程+事件队列。

### 文件操作
1. 文件状态获取
	```
    const fs = require('fs');
    console.log(1);
    fs.stat('./abc', (err, stat) => {
        // 一般回调函数的第一个参数是错误对象，如果err为null,表示没有错误，否则表示报错了
        if (err) return;
        if (stat.isFile()) {
            console.log('文件');
        } else if (stat.isDirectory()) {
            console.log('目录');
        }
        /*
        atime 文件访问时间
        ctime 文件的状态信息发生变化的时间（比如文件的权限）
        mtime 文件数据发生变化的时间
        birthtime 文件创建的时间
        */
        console.log(2);
    });
    console.log(3); 	//输出132
    
    // 同步操作
    console.log(1);
    let ret = fs.statSync('./data.txt');
    console.log(ret);
    console.log(2);      //输出1ret2
	```

2. 读文件操作
	+ readFile(file[,options],callback)  
	如果有第二个参数并且是编码，那么回调函数获取到的数据就是字符串;
	如果没有第二个参数，那么得到的就是Buffer实例对象
	+ readFileSync(file[,options])
3. 写文件操作
	+ fs.writeFile(file, data[, encoding], callback)
	+ fs.writeFileSync(file, data[, encoding])
4. 流处理操作
	```
	let spath = path.join(__dirname,'../03-source','file.zip');
	let dpath = path.join('C:\\Users\\www\\Desktop','file.zip');
	let readStream = fs.createReadStream(spath);
	let writeStream = fs.createWriteStream(dpath);
	let num = 1;
	readStream.on('data',(chunk)=>{
		num++;
		writeStream.write(chunk);
	});

	readStream.on('end',()=>{
		console.log('文件处理完成'+num);
	});

	readStream.pipe(writeStream); //管道提供了一个输出流到输入流的机制。
	```

5. 目录操作
	1. 创建目录
	    ```
        fs.mkdir(path[, mode], callback)
        fs.mkdirSync(path[, mode])
        ```
    2. 读取目录
        ```
        fs.readdir(path[, options], callback)
        fs.readdirSync(path[, options])
        ```
    3. 删除目录
        ```
        fs.rmdir(path, callback)
        fs.rmdirSync(path)
        ```

### 文件操作案例

## 包
> 多个模块可以形成包，不过要满足特定的规则才能形成规范的包

### NPM （node.js package management）
> 全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具。

- [官方网站](https://www.npmjs.com/ )

### npm包安装方式
- 本地安装
- 全局安装

### 解决npm安装包被墙的问题
- --registry
    + npm config set registry=https//registry.npm.taobao.org 
- cnpm
    + 淘宝NPM镜像,与官方NPM的同步频率目前为10分钟一次 
    + 官网: http://npm.taobao.org/ 
    + npm install -g cnpm –registry=https//registry.npm.taobao.org 
    + 使用cnpm安装包: cnpm install 包名
- nrm
    + 作用：修改镜像源 
    + 项目地址：https://www.npmjs.com/package/nrm 
    + 安装：npm install -g nrm

### npm常用命令
- 安装包
- 更新包
- 卸载包

### yarn基本使用
- 类比npm基本使用

## 自定义包
### 包的规范
- package.json必须在包的顶层目录下
- 二进制文件应该在bin目录下
- JavaScript代码应该在lib目录下
- 文档应该在doc目录下
- 单元测试应该在test目录下

### package.json字段分析
- name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格
- description：包的简要说明
- version：符合语义化版本识别规范的版本字符串
- keywords：关键字数组，通常用于搜索
- maintainers：维护者数组，每个元素要包含name、email（可选）、web（可选）字段
- contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一- 个元素
- bugs：提交bug的地址，可以是网站或者电子邮件地址
- licenses：许可证数组，每个元素要包含type（许可证名称）和url（链接到许可证文本的- 地址）字段
- repositories：仓库托管地址数组，每个元素要包含type（仓库类型，如git）、url（仓- 库的地址）和path（相对于仓库的路径，可选）字段
- dependencies：生产环境包的依赖，一个关联数组，由包的名称和版本号组成
- devDependencies：开发环境包的依赖，一个关联数组，由包的名称和版本号组成

### 自定义包案例

